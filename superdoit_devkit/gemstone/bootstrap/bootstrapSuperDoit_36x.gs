! superDoit fileout
!	2021-08-05T16:29:12.070280-07:00

! Class Declarations
! Generated file, do not Edit

doit
(Object
	subclass: 'SuperDoitAbstractOption'
	instVarNames: #( longName shortName value )
	classVars: #( NotSet NoValue )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Option';
		immediateInvariant.
true.
%

doit
(SuperDoitAbstractOption
	subclass: 'SuperDoitAbstractOptionWithRequiredArgument'
	instVarNames: #( defaultValue )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Option';
		immediateInvariant.
true.
%

doit
(SuperDoitAbstractOptionWithRequiredArgument
	subclass: 'SuperDoitOptionalOptionWithRequiredArg'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Option';
		immediateInvariant.
true.
%

doit
(SuperDoitOptionalOptionWithRequiredArg
	subclass: 'SuperDoitRequiredOptionWithRequiredArg'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Option';
		immediateInvariant.
true.
%

doit
(SuperDoitAbstractOption
	subclass: 'SuperDoitOptionalOptionWithNoArg'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Option';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'SuperDoitCommand'
	instVarNames: #( chunk )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitCustomOptionsCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCustomOptionsCommand
	subclass: 'SuperDoitOptionsCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitDoitCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitExtensionMethodCommand'
	instVarNames: #( className isMeta )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitInputCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitInstVarNamesCommand'
	instVarNames: #( executed )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitMethodCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitProjectsHomeCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitScriptCommentCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitSpecsCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitSpecUrlsCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(SuperDoitCommand
	subclass: 'SuperDoitUsageCommand'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'SuperDoitCommandDefinition'
	instVarNames: #( commands )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Command';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'SuperDoitCommandParser'
	instVarNames: #( stream done doitResult usage specs superDoitExecutionClass instVarNames scriptArgs scriptPath systemDictionary optionsDict projectsHome commandDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Core';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'SuperDoitExecution'
	instVarNames: #( _commandLine _scriptArgs _scriptPath _usage _noResult _positionalArgs _loadSpecs _optionsDict )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #()
)
		category: 'SuperDoit-Core';
		immediateInvariant.
true.
%

! Class implementation for 'SuperDoitAbstractOption'

!		Class methods for 'SuperDoitAbstractOption'

category: 'instance creation'
classmethod: SuperDoitAbstractOption
long: longName
	^ self new
		initialize;
		longName: longName;
		yourself
%

category: 'instance creation'
classmethod: SuperDoitAbstractOption
long: longName short: shortName
	^ self new
		initialize;
		longName: longName;
		shortName: shortName;
		yourself
%

category: 'accessing'
classmethod: SuperDoitAbstractOption
notSet
	^ NotSet ifNil: [ NotSet := Object new ]
%

category: 'accessing'
classmethod: SuperDoitAbstractOption
noValue
	^ NoValue ifNil: [ NoValue := Object new ]
%

!		Instance methods for 'SuperDoitAbstractOption'

category: 'testing'
method: SuperDoitAbstractOption
argExpected
	^ false
%

category: 'testing'
method: SuperDoitAbstractOption
argRequired
	^ false
%

category: 'accessing'
method: SuperDoitAbstractOption
defaultValue
	^ false
%

category: 'initialization'
method: SuperDoitAbstractOption
initialize
	value := self notSet
%

category: 'testing'
method: SuperDoitAbstractOption
isRequired
	^ false
%

category: 'accessing'
method: SuperDoitAbstractOption
longName
	^longName
%

category: 'accessing'
method: SuperDoitAbstractOption
longName: object
	longName := object
%

category: 'accessing'
method: SuperDoitAbstractOption
notSet
	^ self class notSet
%

category: 'accessing'
method: SuperDoitAbstractOption
noValue
	^ self class noValue
%

category: 'accessing'
method: SuperDoitAbstractOption
shortName
	^shortName
%

category: 'accessing'
method: SuperDoitAbstractOption
shortName: object
	shortName := object
%

category: 'accessing'
method: SuperDoitAbstractOption
value
	^ value == self notSet
		ifTrue: [ self defaultValue ]
		ifFalse: [ value ]
%

category: 'accessing'
method: SuperDoitAbstractOption
value: object
	value ~~ self notSet
		ifTrue: [ 
			self
				error:
					'The option ' , self longName printString , ' has already been processed.' ].
	value := object
%

category: 'testing'
method: SuperDoitAbstractOption
wasSet
	"answer true if the receiver was set on the command line"

	^ value ~~ self notSet
%

! Class implementation for 'SuperDoitAbstractOptionWithRequiredArgument'

!		Class methods for 'SuperDoitAbstractOptionWithRequiredArgument'

category: 'instance creation'
classmethod: SuperDoitAbstractOptionWithRequiredArgument
long: longName default: default
	^ self new
		initialize;
		longName: longName;
		defaultValue: default;
		yourself
%

category: 'instance creation'
classmethod: SuperDoitAbstractOptionWithRequiredArgument
long: longName short: shortName default: default
	^ self new
		initialize;
		longName: longName;
		shortName: shortName;
		defaultValue: default;
		yourself
%

!		Instance methods for 'SuperDoitAbstractOptionWithRequiredArgument'

category: 'testing'
method: SuperDoitAbstractOptionWithRequiredArgument
argExpected
	^ true
%

category: 'accessing'
method: SuperDoitAbstractOptionWithRequiredArgument
defaultValue
	^defaultValue
%

category: 'accessing'
method: SuperDoitAbstractOptionWithRequiredArgument
defaultValue: object
	defaultValue := object
%

category: 'accessing'
method: SuperDoitAbstractOptionWithRequiredArgument
markNoValue
	"mark with a noValue object that is unique when the optional options have been referenced on command line, should trigger use of defaultValue"

	(value ~~ self notSet and: [ value ~~ self noValue])
		ifTrue: [ 
			self
				error:
					'The option ' , self longName printString , ' has already been processed.' ].
	value := self noValue
%

category: 'accessing'
method: SuperDoitAbstractOptionWithRequiredArgument
value
	^ (value == self noValue or: [ value == self notSet ])
		ifTrue: [ self defaultValue ]
		ifFalse: [ value ]
%

! Class implementation for 'SuperDoitOptionalOptionWithRequiredArg'

!		Instance methods for 'SuperDoitOptionalOptionWithRequiredArg'

category: 'testing'
method: SuperDoitOptionalOptionWithRequiredArg
argRequired
	^ true
%

! Class implementation for 'SuperDoitRequiredOptionWithRequiredArg'

!		Class methods for 'SuperDoitRequiredOptionWithRequiredArg'

category: 'instance creation'
classmethod: SuperDoitRequiredOptionWithRequiredArg
long: longName default: default
	self
		error:
			'required options with required arguments have no default value, use long: instead'
%

category: 'instance creation'
classmethod: SuperDoitRequiredOptionWithRequiredArg
long: longName short: shortName default: default
	self
		error:
			'required options with required arguments have no default value, use long:short: instead'
%

!		Instance methods for 'SuperDoitRequiredOptionWithRequiredArg'

category: 'testing'
method: SuperDoitRequiredOptionWithRequiredArg
isRequired
	^ true
%

! Class implementation for 'SuperDoitCommand'

!		Class methods for 'SuperDoitCommand'

category: 'instance creation'
classmethod: SuperDoitCommand
chunk: aString
	^ self new
		chunk: aString;
		yourself
%

!		Instance methods for 'SuperDoitCommand'

category: 'accessing'
method: SuperDoitCommand
chunk
	^chunk
%

category: 'accessing'
method: SuperDoitCommand
chunk: object
	chunk := object
%

category: 'execution'
method: SuperDoitCommand
executeAgainst: aCommandParser
	self subclassResponsibility: #'executeAgainst:'
%

category: 'execution'
method: SuperDoitCommand
preClassCreationExecuteAgainst: aCommandParser
	"give all commands that need to be executed BEFORE class creation a chance to run"

	"noop by default"
%

! Class implementation for 'SuperDoitCustomOptionsCommand'

!		Instance methods for 'SuperDoitCustomOptionsCommand'

category: 'execution'
method: SuperDoitCustomOptionsCommand
executeAgainst: aCommandParser
	| ivNames optionSpecs optionsDict |
	ivNames := aCommandParser instVarNames.
	optionSpecs := self optionSpecs: aCommandParser.
	optionsDict := Dictionary new.
	optionSpecs do: [ :spec | optionsDict at: spec longName put: spec ].
	aCommandParser optionsDict: optionsDict.
	optionSpecs
		do: [ :option | 
			| longName |
			longName := option longName.
			aCommandParser superDoitExecutionClass
				compileMethod:
					longName , '  ^ (self optionsDict at: ' , longName printString , ') value'.
			aCommandParser superDoitExecutionClass
				compileMethod:
					longName , ': optionValue (self optionsDict at:' , longName printString
						, ') value: optionValue' ]
%

category: 'accessing'
method: SuperDoitCustomOptionsCommand
optionSpecs: aCommandParser
	| ar |
	ar := self chunk evaluate.
	ar _isArray
		ifFalse: [ self error: 'Expected an Array of options: ' , ar printString ].
	^ ar
%

! Class implementation for 'SuperDoitOptionsCommand'

!		Instance methods for 'SuperDoitOptionsCommand'

category: 'accessing'
method: SuperDoitOptionsCommand
optionSpecs: aCommandParser
	^ aCommandParser standardOptionSpecs , (super optionSpecs: aCommandParser)
%

! Class implementation for 'SuperDoitDoitCommand'

!		Instance methods for 'SuperDoitDoitCommand'

category: 'execution'
method: SuperDoitDoitCommand
executeAgainst: aCommandParser
	| instance |
	aCommandParser superDoitExecutionClass
		compileMethod:
			'theDoit ^ ' , self chunk printString
				,
					' evaluateInContext: self 
				symbolList: GsCurrentSession currentSession transientSymbolList '.
	instance := aCommandParser superDoitExecutionClass new.
	instance scriptPath: aCommandParser scriptPath.
	instance scriptArgs: aCommandParser scriptArgs.
	instance usage: aCommandParser usage.
	instance optionsDict: aCommandParser optionsDict.
	instance processDynamicSections: aCommandParser.
	instance _loadSpecs: aCommandParser specs.
	instance displayResult: instance doit
%

! Class implementation for 'SuperDoitExtensionMethodCommand'

!		Class methods for 'SuperDoitExtensionMethodCommand'

category: 'instance creation'
classmethod: SuperDoitExtensionMethodCommand
chunk: aString className: className
	^ self new
		chunk: aString;
		className: className;
		yourself
%

category: 'instance creation'
classmethod: SuperDoitExtensionMethodCommand
chunk: aString className: className isMeta: aBool
	^ self new
		chunk: aString;
		className: className;
		isMeta: aBool;
		yourself
%

!		Instance methods for 'SuperDoitExtensionMethodCommand'

category: 'accessing'
method: SuperDoitExtensionMethodCommand
className
	^className
%

category: 'accessing'
method: SuperDoitExtensionMethodCommand
className: object
	className := object
%

category: 'execution'
method: SuperDoitExtensionMethodCommand
executeAgainst: aCommandParser
	(Rowan globalNamed: self className)
		ifNotNil: [ :class | 
			| beh |
			beh := self isMeta
				ifTrue: [ class class ]
				ifFalse: [ class ].
			beh compileMethod: self chunk ]
		ifNil: [ self error: 'No class ' , className printString , ' found' ]
%

category: 'accessing'
method: SuperDoitExtensionMethodCommand
isMeta
	^ isMeta ifNil: [ false ]
%

category: 'accessing'
method: SuperDoitExtensionMethodCommand
isMeta: object
	isMeta := object
%

! Class implementation for 'SuperDoitInputCommand'

!		Instance methods for 'SuperDoitInputCommand'

category: 'execution'
method: SuperDoitInputCommand
executeAgainst: aCommandParser
	| inputFileStream |
	inputFileStream := self chunk readStreamPortable.
	[ inputFileStream atEnd ]
		whileFalse: [ 
			| filePath |
			filePath := inputFileStream nextLine.
			GsFileIn fromServerPath: filePath ]
%

! Class implementation for 'SuperDoitInstVarNamesCommand'

!		Instance methods for 'SuperDoitInstVarNamesCommand'

category: 'execution'
method: SuperDoitInstVarNamesCommand
executeAgainst: aCommandParser
	self executed ifTrue: [ ^ self ].
	aCommandParser
		instVarNames: aCommandParser instVarNames , ('#(' , self chunk , ')') evaluate.
	self executed: true
%

category: 'accessing'
method: SuperDoitInstVarNamesCommand
executed
	^ executed ifNil: [ executed := false ]
%

category: 'accessing'
method: SuperDoitInstVarNamesCommand
executed: object
	executed := object
%

category: 'execution'
method: SuperDoitInstVarNamesCommand
preClassCreationExecuteAgainst: aCommandParser
	"give all commands that need to be executed BEFORE class creation a chance to run"

	self executeAgainst: aCommandParser
%

! Class implementation for 'SuperDoitMethodCommand'

!		Instance methods for 'SuperDoitMethodCommand'

category: 'execution'
method: SuperDoitMethodCommand
executeAgainst: aCommandParser
	aCommandParser superDoitExecutionClass compileMethod: self chunk
%

! Class implementation for 'SuperDoitProjectsHomeCommand'

!		Instance methods for 'SuperDoitProjectsHomeCommand'

category: 'execution'
method: SuperDoitProjectsHomeCommand
executeAgainst: aCommandParser
	| projectsHomeStream |
	projectsHomeStream := self chunk readStreamPortable.
	[ projectsHomeStream atEnd ]
		whileFalse: [ 
			"last declaration wins"
			aCommandParser projectsHome: projectsHomeStream nextLine ]
%

! Class implementation for 'SuperDoitScriptCommentCommand'

!		Instance methods for 'SuperDoitScriptCommentCommand'

category: 'execution'
method: SuperDoitScriptCommentCommand
executeAgainst: aCommandParser
	"noop"
%

! Class implementation for 'SuperDoitSpecsCommand'

!		Instance methods for 'SuperDoitSpecsCommand'

category: 'execution'
method: SuperDoitSpecsCommand
executeAgainst: aCommandParser
	| stonStream |
	stonStream := self chunk readStreamPortable.
	[ stonStream atEnd ]
		whileFalse: [ 
			| obj |
			obj := STON fromStream: stonStream.
			obj _isArray
				ifTrue: [ 
					aCommandParser specs
						addAll:
							(obj
								collect: [ :each | 
									each
										projectsHome: aCommandParser projectsHome;
										yourself ]) ]
				ifFalse: [ 
					obj projectsHome: aCommandParser projectsHome.
					aCommandParser specs add: obj ] ]
%

! Class implementation for 'SuperDoitSpecUrlsCommand'

!		Instance methods for 'SuperDoitSpecUrlsCommand'

category: 'execution'
method: SuperDoitSpecUrlsCommand
executeAgainst: aCommandParser
	| urlStream |
	urlStream := self chunk readStreamPortable.
	[ urlStream atEnd ]
		whileFalse: [ 
			| url spec |
			url := urlStream nextLine.
			spec := (RwSpecification fromUrl: url)
				projectsHome: aCommandParser projectsHome;
				yourself.
			aCommandParser specs add: spec ]
%

! Class implementation for 'SuperDoitUsageCommand'

!		Instance methods for 'SuperDoitUsageCommand'

category: 'execution'
method: SuperDoitUsageCommand
executeAgainst: aCommandParser
	aCommandParser usage: self chunk
%

! Class implementation for 'SuperDoitCommandDefinition'

!		Instance methods for 'SuperDoitCommandDefinition'

category: 'creation'
method: SuperDoitCommandDefinition
addCommand: aSuperDoitCommand
	self commands add: aSuperDoitCommand
%

category: 'accessing'
method: SuperDoitCommandDefinition
commands
	^ commands ifNil: [ commands := OrderedCollection new ]
%

category: 'execution'
method: SuperDoitCommandDefinition
executeAgainst: aCommandParser
	self commands do: [ :command | command executeAgainst: aCommandParser ]
%

category: 'execution'
method: SuperDoitCommandDefinition
preClassCreationExecuteAgainst: aCommandParser
	"give all commands that need to be executed BEFORE class creation a chance to run"

	self commands
		do: [ :command | command preClassCreationExecuteAgainst: aCommandParser ]
%

! Class implementation for 'SuperDoitCommandParser'

!		Class methods for 'SuperDoitCommandParser'

category: 'instance creation'
classmethod: SuperDoitCommandParser
processInputFile
	"command line looks like the following:
		<path-to-topaz>/topaz <topaz arguments> -- <script-file-path> -- <script-args>
	"

	| args scriptArgStart argIndex scriptPath scriptFile scriptArgs scriptArgIndex |
	args := System commandLineArguments.
	scriptArgStart := args indexOf: '--'.
	argIndex := scriptArgStart + 1.	"arg after initial --"
	(scriptArgStart <= 0 or: [ argIndex > args size ])
		ifTrue: [ self error: 'input file is expected to be specified on the command line' ].
	scriptFile := args at: argIndex.
	scriptArgIndex := args indexOf: '--' startingAt: argIndex + 1.
	scriptArgs := scriptArgIndex = 0
		ifTrue: [ #() ]
		ifFalse: [ args copyFrom: scriptArgIndex + 1 to: args size ].
	 
	scriptPath := scriptFile asFileReference.
	^ self new 
		scriptPath: scriptPath;
		scriptArgs: scriptArgs;
		parseAndExecuteScriptFile: scriptPath;
		yourself
%

!		Instance methods for 'SuperDoitCommandParser'

category: 'commands'
method: SuperDoitCommandParser
classMethod: aString className: className
	^ SuperDoitExtensionMethodCommand
		chunk: aString
		className: className
		isMeta: true
%

category: 'accessing'
method: SuperDoitCommandParser
commandDefinition
	^ commandDefinition
		ifNil: [ commandDefinition := SuperDoitCommandDefinition new ]
%

category: 'commands'
method: SuperDoitCommandParser
customOptions: string
	^ SuperDoitCustomOptionsCommand chunk: string
%

category: 'commands'
method: SuperDoitCommandParser
doit: aString
	^ SuperDoitDoitCommand chunk: aString
%

category: 'accessing'
method: SuperDoitCommandParser
done
^ done ifNil: [ false ]
%

category: 'commands'
method: SuperDoitCommandParser
input: aString
	^ SuperDoitInputCommand chunk: aString
%

category: 'accessing'
method: SuperDoitCommandParser
instVarNames
	^ instVarNames ifNil: [ instVarNames := {} ]
%

category: 'accessing'
method: SuperDoitCommandParser
instVarNames: anArray
	instVarNames := anArray
%

category: 'commands'
method: SuperDoitCommandParser
instVarNamesCommand: string
	^ SuperDoitInstVarNamesCommand chunk: string
%

category: 'commands'
method: SuperDoitCommandParser
method: aString
	^ SuperDoitMethodCommand chunk: aString
%

category: 'commands'
method: SuperDoitCommandParser
method: aString className: className
	^ SuperDoitExtensionMethodCommand chunk: aString className: className
%

category: 'parsing'
method: SuperDoitCommandParser
nextChunk
	| str line |
	str := String new.
	[ stream atEnd not ]
		whileTrue: [ 
			line := stream nextLine trimTrailingSeparators.
			(line notEmpty and: [ line first = $% ])
				ifTrue: [ ^ str ].
			str
				addAll: line;
				lf ].
	self error: 'ran off end of file!'
%

category: 'commands'
method: SuperDoitCommandParser
options: string
	^ SuperDoitOptionsCommand chunk: string
%

category: 'accessing'
method: SuperDoitCommandParser
optionsDict
	^optionsDict
%

category: 'accessing'
method: SuperDoitCommandParser
optionsDict: object
	optionsDict := object
%

category: 'execution'
method: SuperDoitCommandParser
parseAndExecuteScriptFile: scriptFileReference
	scriptFileReference
		readStreamDo: [ :fStream | 
			stream := ZnBufferedReadStream on: fStream.
			[ self done ]
				whileFalse: [ 
					self processNextCommand
						ifNotNil: [ :command | self commandDefinition addCommand: command ] ].
			optionsDict
				ifNil: [ 
					"no options specified, so go with the standard options and add it at the beginning of commands"
					self commandDefinition commands addFirst: (SuperDoitOptionsCommand chunk: '{}') ].
			self commandDefinition preClassCreationExecuteAgainst: self. "make a pass to ensure that all commands that need to be processed BEFORE class creation get a chance to run (i'm looking at you SuperDoitInstVarNamesCommand"
			self commandDefinition executeAgainst: self.
			^ doitResult ]
%

category: 'parsing'
method: SuperDoitCommandParser
processNextCommand
	| line words command commandSelector |
	stream atEnd
		ifTrue: [ 
			done := true.
			^ nil ].
	line := stream nextLine trimSeparators.
	words := line subStrings.
	words isEmpty
		ifTrue: [ ^ nil ].

	command := words first asUppercase.
	(command at: 1) == $#
		ifTrue: [ ^ self scriptComment: line ].
	command = 'DOIT'
		ifTrue: [ ^ self doit: self nextChunk ].
	command = 'METHOD'
		ifTrue: [ ^ self method: self nextChunk ].
	command = 'METHOD:'
		ifTrue: [ ^ self method: self nextChunk className: (words at: 2) ].
	command = 'CLASSMETHOD:'
		ifTrue: [ ^ self classMethod: self nextChunk className: (words at: 2) ].
	command = 'INPUT'
		ifTrue: [ ^ self input: self nextChunk ].
	command = 'OPTIONS'
		ifTrue: [ ^ self options: self nextChunk ].
	command = 'CUSTOMOPTIONS'
		ifTrue: [ ^ self customOptions: self nextChunk ].
	command = 'INSTVARS'
		ifTrue: [ ^ self instVarNamesCommand: self nextChunk ].
	command = 'PROJECTSHOME'
		ifTrue: [ ^ self projectsHomeCommand: self nextChunk ].
	command = 'SPECS'
		ifTrue: [ ^ self specsCommand: self nextChunk ].
	command = 'SPECURLS'
		ifTrue: [ ^ self specUrls: self nextChunk ].
	command = 'USAGE'
		ifTrue: [ ^ self usageCommand: self nextChunk ].
	commandSelector := (command asLowercase , ':') asSymbol.
	(self respondsTo: commandSelector)
		ifTrue: [ ^ self perform: commandSelector with: self nextChunk ].
	self error: 'Unknown command ' , command printString
%

category: 'accessing'
method: SuperDoitCommandParser
projectsHome
	^ projectsHome ifNil: [ '$ROWAN_PROJECTS_HOME' ]
%

category: 'accessing'
method: SuperDoitCommandParser
projectsHome: aString
	projectsHome := aString
%

category: 'commands'
method: SuperDoitCommandParser
projectsHomeCommand: string
	^ SuperDoitProjectsHomeCommand chunk: string
%

category: 'accessing'
method: SuperDoitCommandParser
scriptArgs
^ scriptArgs ifNil: [ #() ]
%

category: 'accessing'
method: SuperDoitCommandParser
scriptArgs: aColl
 scriptArgs := aColl
%

category: 'commands'
method: SuperDoitCommandParser
scriptComment: aString
	^ SuperDoitScriptCommentCommand chunk: aString
%

category: 'accessing'
method: SuperDoitCommandParser
scriptPath
	^ scriptPath
%

category: 'accessing'
method: SuperDoitCommandParser
scriptPath: aFileReference
	scriptPath := aFileReference
%

category: 'accessing'
method: SuperDoitCommandParser
specs
	^ specs ifNil: [ specs := {} ]
%

category: 'commands'
method: SuperDoitCommandParser
specsCommand: string
	^ SuperDoitSpecsCommand chunk: string
%

category: 'commands'
method: SuperDoitCommandParser
specUrls: string
	^ SuperDoitSpecUrlsCommand chunk: string
%

category: 'accessing'
method: SuperDoitCommandParser
standardOptionSpecs
	^ {(SuperDoitOptionalOptionWithNoArg long: 'help' short: 'h').
	(SuperDoitOptionalOptionWithNoArg long: 'debug' short: 'D')}
%

category: 'accessing'
method: SuperDoitCommandParser
superDoitExecutionClass
	^ superDoitExecutionClass
		ifNil: [ 
			superDoitExecutionClass := SuperDoitExecution
				subclass: 'SuperDoitExecutionClass'
				instVarNames: self instVarNames
				classVars: #()
				classInstVars: #()
				poolDictionaries: #()
				inDictionary: self systemDictionary ]
%

category: 'accessing'
method: SuperDoitCommandParser
systemDictionary
	"install the script class in a symbol dictionary in the transient symbol list ... 
		we do not want the class persisted"

	^ systemDictionary
		ifNil: [ 
			| sess symbolList name |
			sess := GsCurrentSession currentSession.
			sess _transientSymbolList ifNil: [ System refreshTransientSymbolList ].
			symbolList := sess transientSymbolList.
			name := #'superDoitSymbolDict'.
			^ systemDictionary := (symbolList resolveSymbol: name)
				ifNil: [ 
					systemDictionary := SymbolDictionary new name: name.
					symbolList insertObject: systemDictionary at: 1 ] ]
%

category: 'accessing'
method: SuperDoitCommandParser
usage
	^ usage
		ifNil: [ 
			| stoneArgs stoneName |
			GsSession isSolo
				ifTrue: [ stoneName := stoneArgs := '' ]
				ifFalse: [ 
					stoneName := '-- gs_360'.
					stoneArgs := ' [-- [<stone-name> [<topaz-command-line-args>] ] ]' ].
			^ '-----
USAGE $basename [--help | -h] [--debug | -D]' , stoneArgs
				,
					'

OPTIONS
  -h, --help                 display usage message
  -D, --debug                bring up topaz debugger in the event of a script error

EXAMPLES
  $basename --help  ' , stoneName
				,
					'
  $basename -h      ' , stoneName
				,
					'
  $basename --debug ' , stoneName
				,
					'
  $basename -D      ' , stoneName
				,
					'
  $basename         ' , stoneName
				,
					'
-----
' ]
%

category: 'accessing'
method: SuperDoitCommandParser
usage: string
	"any env var refs in string should be substituted upon display"
	usage := string
%

category: 'commands'
method: SuperDoitCommandParser
usageCommand: string
	^ SuperDoitUsageCommand chunk: string
%

! Class implementation for 'SuperDoitExecution'

!		Instance methods for 'SuperDoitExecution'

category: 'script info'
method: SuperDoitExecution
basename
	^ self scriptPath basename
%

category: 'command line'
method: SuperDoitExecution
commandLine
	^ _commandLine
		ifNil: [ 
			| stream |
			stream := WriteStream on: String new.
			stream
				nextPutAll: self basename;
				space.
			2 to: _scriptArgs size do: [ :index | 
				stream
					nextPutAll: (_scriptArgs at: index);
					space ].
			_commandLine := stream contents ]
%

category: 'command line'
method: SuperDoitExecution
commandLine: aString
	_commandLine := aString
%

category: 'command line'
method: SuperDoitExecution
commandLineSummary
	| opts |
	opts := Dictionary new.
	self optionsDict do: [:option |
		option wasSet
			ifTrue: [ opts at: option longName put: option value ] ].
	^ Dictionary new
		at: 'options' put: opts;
		at: 'args' put: self positionalArgs; 
		yourself.
%

category: 'script info'
method: SuperDoitExecution
dirname
	^ self scriptPath parent
%

category: 'logging'
method: SuperDoitExecution
displayResult: anObject
	anObject ~~ self noResult
		ifTrue: [ self ston: anObject on: self stdout ]
%

category: 'script execution'
method: SuperDoitExecution
doit
	"standard option handling ... for customization override in script"

	[ 
	self getAndVerifyOptions == self noResult
		ifTrue: [ ^ self noResult ].
	^ self theDoit ]
		on: Error
		do: [ :ex | 
			((self respondsTo: #'debug') and: [ self debug ])
				ifTrue: [ ex pass ].
			self exit: ex messageText withStatus: 1	"does not return" ]
%

category: 'script info'
method: SuperDoitExecution
executionStoneName
	^GsNetworkResourceString currentStoneName
%

category: 'exit'
method: SuperDoitExecution
exit: message withStatus: statusInteger
	"Does not return and terminates the os process with exit status <statusInteger>"

	self logErrorMessage: message.
	ExitClientError signal: 'explicit process exit' status: statusInteger
%

category: 'exit'
method: SuperDoitExecution
exitWithStatus: statusInteger
	"Does not return and terminates the os process with exit status <statusInteger>"

	ExitClientError signal: 'explicit process exit' status: statusInteger
%

category: 'script execution'
method: SuperDoitExecution
getAndVerifyOptions
	"standard option handling ... for customization override in script"

	self getOpts.
	((self respondsTo: #'help') and: [ self help ])
		ifTrue: [ ^ self usage ].
	self optionsDict
		keysAndValuesDo: [ :longName :option | 
			option isRequired
				ifTrue: [ 
					option wasSet
						ifFalse: [ self error: 'The required option ' , longName printString , ' was not set.' ] ] ]
%

category: 'command line'
method: SuperDoitExecution
getOpts
	| argStream opt theArgs specsDict |
	specsDict := self _specsDict.
	_positionalArgs := {}.
	theArgs := self scriptArgs asArray.
	theArgs size = 0
		ifTrue: [ ^ self ].
	argStream := ReadStream on: (theArgs copyFrom: 1 to: theArgs size).
	[ argStream atEnd ]
		whileFalse: [ 
			| optOrArg |
			optOrArg := argStream next.
			(optOrArg = '--' or: [ optOrArg = '-' ])
				ifTrue: [ self error: 'Cannot handle naked dashes ' , optOrArg printString ].
			opt
				ifNotNil: [ :theOpt | 
					theOpt argExpected
						ifTrue: [ 
							(optOrArg beginsWith: '-')
								ifTrue: [ 
									theOpt argRequired
										ifTrue: [ 
											self
												error:
													'Missing required argument for option ' , opt longName printString , ' [a]' ]
										ifFalse: [ theOpt markNoValue	"will pick up default value" ] ]
								ifFalse: [ theOpt value: optOrArg ] ]
						ifFalse: [ theOpt value: true	"set value to true, to indicate that the option WAS specified" ] ].
			(optOrArg beginsWith: '-')
				ifTrue: [ 
					(optOrArg beginsWith: '--')
						ifTrue: [ 
							| optKey |
							optKey := optOrArg copyFrom: 3 to: optOrArg size.
							(optKey indexOf: $= ifAbsent: [  ])
								ifNotNil: [ :index | 
									| arg |
									"long option with value"
									arg := optKey copyFrom: index + 1 to: optKey size.
									optKey := optKey copyFrom: 1 to: index - 1.
									opt := (specsDict at: 'long')
										at: optKey
										ifAbsent: [ self error: 'Unknown option ' , optKey printString , ' [a]' ].
									opt argExpected
										ifFalse: [ 
											self
												error:
													'Unexpected argument ' , arg printString , ' for option ' , optKey printString ].
									opt value: arg ]
								ifNil: [ 
									"naked long option"
									opt := (specsDict at: 'long')
										at: optKey
										ifAbsent: [ self error: 'Unknown option ' , optKey printString , ' [b]' ].
									opt argRequired
										ifTrue: [ 
											self
												error:
													'Missing required argument for option ' , optKey printString , ' [b]' ].
									opt argExpected
										ifTrue: [ opt markNoValue ]
										ifFalse: [ opt value: true ] ].
							opt := nil ]
						ifFalse: [ 
							| theOpts numOpts |
							"optOrArg beginsWith: '-'"
							theOpts := optOrArg copyFrom: 2 to: optOrArg size.
							numOpts := theOpts size.
							1 to: numOpts do: [ :index | 
								| optKey |
								optKey := (theOpts at: index) asString.
								opt := (specsDict at: 'short')
									at: optKey
									ifAbsent: [ self error: 'Unknown option ' , optKey printString , ' [c]' ].
								index < numOpts
									ifTrue: [ 
										"multiple options"
										opt argRequired
											ifTrue: [ 
												self
													error:
														'Missing required argument for option ' , opt longName printString , ' [c]' ].
										opt argExpected
											ifTrue: [ opt markNoValue ]
											ifFalse: [ opt value: true ] ]
									ifFalse: [ 
										opt argExpected
											ifFalse: [ 
												opt value: true.
												opt := nil ] ] ] ] ]
				ifFalse: [ 
					opt
						ifNil: [ 
							"naked arg"
							_positionalArgs add: optOrArg ]
						ifNotNil: [ 
							"op has already had it's option set"
							opt := nil ] ] ].
	opt
		ifNotNil: [ 
			"naked option"
			opt argRequired
				ifTrue: [ 
					self
						error:
							'Missing required argument for option ' , opt longName printString , ' [d]' ].
			opt argExpected
				ifTrue: [ opt markNoValue ]
				ifFalse: [ opt value: true ] ]
%

category: 'script info'
method: SuperDoitExecution
isSolo
	^ GsSession isSolo
%

category: 'logging'
method: SuperDoitExecution
log: anObject
	| stdout |
	stdout := GsFile stdout.
	self ston: anObject on: stdout.
	stdout lf
%

category: 'logging'
method: SuperDoitExecution
logErrorMessage: aString
	self stderr
		nextPutAll: aString;
		lf
%

category: 'logging'
method: SuperDoitExecution
logMessage: aString
	self stdout
		nextPutAll: aString;
		lf
%

category: 'private'
method: SuperDoitExecution
noResult
	"unique object to use a return value when no result should be written to stdout"

	^ _noResult ifNil: [ _noResult := Object new ]
%

category: 'accessing'
method: SuperDoitExecution
optionsDict
	^_optionsDict
%

category: 'accessing'
method: SuperDoitExecution
optionsDict: object
	_optionsDict := object
%

category: 'accessing'
method: SuperDoitExecution
positionalArgs
	^_positionalArgs
%

category: 'accessing'
method: SuperDoitExecution
positionalArgs: object
	_positionalArgs := object
%

category: 'doit'
method: SuperDoitExecution
preDoitSpecLoad
	"create a project set from the specs and load the whole enchilada"

	"return list of RwProjects loaded"

	^ self preDoitSpecLoad: [  ]
%

category: 'doit'
method: SuperDoitExecution
preDoitSpecLoad: specBlock
	"create a project set from the specs and load the whole enchilada"

	"return list of RwProjects loaded"

	| projectSet |
	self _loadSpecs isEmpty
		ifTrue: [ ^ self ].
	projectSet := RwProjectSetDefinition new.
	self _loadSpecs
		do: [ :spec | 
			specBlock cull: spec.
			projectSet addAll: spec resolve readProjectSet ].
	^ projectSet load
%

category: 'accessing'
method: SuperDoitExecution
processDynamicSections: aSuperDoitCommandParser
	"placeholder for picking up dynamic section content"

	"noop"
%

category: 'accessing'
method: SuperDoitExecution
scriptArgs
	^ _scriptArgs ifNil: [ #() ]
%

category: 'accessing'
method: SuperDoitExecution
scriptArgs: aColl
	_scriptArgs := aColl
%

category: 'accessing'
method: SuperDoitExecution
scriptPath
	^ _scriptPath
%

category: 'accessing'
method: SuperDoitExecution
scriptPath: aFileReference
	_scriptPath := aFileReference
%

category: 'logging'
method: SuperDoitExecution
stderr
	^ GsFile stderr
%

category: 'logging'
method: SuperDoitExecution
stdout
	^ GsFile stdout 
%

category: 'private'
method: SuperDoitExecution
ston: anObject on: aStream
	STON put: anObject onStreamPretty: aStream
%

category: 'help'
method: SuperDoitExecution
usage
	| string |
	string := _usage copyReplaceAll: '$basename' with: self basename.
	self stdout nextPutAll: string.
	^ self noResult
%

category: 'help'
method: SuperDoitExecution
usage: object
	_usage := object
%

category: 'accessing'
method: SuperDoitExecution
_loadSpecs
	^ _loadSpecs
%

category: 'accessing'
method: SuperDoitExecution
_loadSpecs: specs
	_loadSpecs := specs
%

category: 'private'
method: SuperDoitExecution
_specsDict
	| specsDict |
	specsDict := Dictionary new
		at: 'long' put: Dictionary new;
		at: 'short' put: Dictionary new;
		yourself.
	self optionsDict
		do: [ :option | 
			(specsDict at: 'long') at: option longName put: option.
			option shortName
				ifNotNil: [ :shortName | (specsDict at: 'short') at: shortName put: option ] ].
	^ specsDict
%

! Class extensions for 'AbstractDictionary'

!		Instance methods for 'AbstractDictionary'

category: '*superdoit-gemstone-kernel'
method: AbstractDictionary
at: key ifPresent: oneArgBlock ifAbsent: absentBlock
	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the oneArgBlock with the value associated with the key, otherwise answer the value of absentBlock."

	self at: key ifPresent: [ :v | ^ oneArgBlock cull: v ].
	^ absentBlock value
%

! Class extensions for 'GsFile'

!		Instance methods for 'GsFile'

category: '*superdoit-gemstone-kernel36x'
method: GsFile
print: anObject
 anObject printOn: self
%

