#!/usr/bin/env superdoit
instvars
%
options
{
	SuperDoitCommandLineOption long: 'help' short: 'h'.
	SuperDoitCommandLineOption long: 'debug'.
	SuperDoitCommandLineOption long: 'both' short: 'b'.
	SuperDoitCommandLineOption long: 'restart' short: 'r'.
	SuperDoitCommandLineOption long: 'conversion' short: 'C'.
	SuperDoitCommandLineOption long: 'notranslogs' short: 'N'.
	SuperDoitCommandLineOption long: 'restore' short: 'R'.
	SuperDoitOptionalCommandLineOption long: 'wait' short: 'w' default: -1.
}
%
usage
-----
USAGE: $basename [-h] [-b] [-C] [-N] [-R] [-r] [-w <waitstone-timeout>] <stone-name>

DESCRIPTION
 Start the stone process for the given stone.

OPTIONS
  -h, --help 	display usage message
	-N, --notranslogs 	Startup without transaction logs.
  -R, --restore 	Startup for restore

The following options not implemented here
  -b, --both 		start both stone and netldi
  -r, --restart 	Restart stone if running
  -C, --conversion 	Startup for conversion.
  -N, --notranslogs 	Startup without transaction logs.
  -R, --restore 	Startup for restore
  -w, --wait 		<waitstone-timeout>
			if present wait up to <waitstone-timeout> minutes for the stone to
			properly start

EXAMPLES
  $basename -h
  $basename myStoneName
  $basename -b myStoneName
  $basename -w myStoneName
-----
%
method
startStone
	| result |
	(self positionalArgs size < 1 or: [ self positionalArgs size > 2 ])
		ifTrue: [
			^ Error signal: 'Wrong number of arguments (' , self positionalArgs size printString , ')' ].
	self shouldNotBeForeignStone.
	result := GsHostProcess execute: (self gs_binDirectory / 'startstone ') fullPath asString, ' ', self passThroughArguments, self positionalArgs first.
	self stderr nextPutAll: result; cr.
%
method
shouldNotBeForeignStone
	self stoneInfo isForeignStone
		ifTrue: [
			^ Error signal:
					'The stone ' , self stoneName printString , ' is a foreign stone and should not be controlled from GsDevKit_home.' ].
%
method
passThroughArguments
	^ String streamContents: [ :stream |
			self notranslogs ifTrue: [ stream nextPutAll: ' -N ' ] ifFalse: [
				self restore ifTrue: [ stream nextPutAll: ' -R ']
			]
		]
%
method
gs_binDirectory
	^ ((System gemEnvironmentVariable: 'GEMSTONE'), '/bin') asFileReference
%
method
gs_stonesDirectory
	^  ((System gemEnvironmentVariable: 'GS_HOME'), '/server/stones') asFileReference
%
method
gs_stoneDirectory
	^  self gs_stonesDirectory / self stoneName
%
method
stoneInfoClass
	^ GsDevKitStoneInfo
%
method
stoneInfoFilename
	^  'info.ston'
%
method
stoneInfo
	^ self stoneInfoClass importFrom: self gs_stoneDirectory / self stoneInfoFilename
%
method
stoneName
	^ self positionalArgs at: 1
%
method
getAndVerifyOptions
	self getOpts: self optionSpecs.
	self help ifTrue: [ ^ self usage ].
%
doit
	[
		self getAndVerifyOptions == self noResult
			ifTrue: [ ^ self noResult ].
		self startStone.
		^ self noResult
	] on: Error do: [:ex |
		self debug ifTrue: [ ex pass ].
		self
			exit: ((ex respondsTo: #stderr)
				ifTrue: [ ex stderr asString trimBoth ]
				ifFalse: [ ex messageText ])
			withStatus: 1 "does not return" ].
%
