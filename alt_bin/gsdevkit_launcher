#!/usr/bin/env bash
#
#

usage() {
  cat <<HELP
USAGE: $(basename $0) scriptPath [ [-H] [-D] [-V] [topaz-vm-args] -- ] [script-args]
       $(basename $0) scriptPath [ [-H] [-D] [-V] [topaz-vm-args] ] -- [script-args] -- [non-option-script-args]

The $(basename $0) -HDV options may be interspersed with the topz-vm-args as of
GemStone 3.5.0.

If non-option-script-args are present, use '--' to terminate the script-args and a 
'--' must precede the script arguments on the command line.

OPTIONS
  -D
     Bring up topaz debugger for Error exceptions. Normally these exceptions result in
     an error message to stderr.
  -H
     Display help message and exit.
  -V
     Verbose output

EXAMPLES
  $(basename $0) -H                   # this message
  $(basename $0) $GS_HOME/alt_bin/examples/hello.st -H --     # this message
  $(basename $0) $GS_HOME/alt_bin/examples/hello.st -- -h     # hello.st help message
	$(basename $0) $GS_HOME/alt_bin/examples/hello.st -- -h     # hello.st help message using default image
  $(basename $0) $GS_HOME/alt_bin/examples/hello.st -- -x 		# run hello.st with an invalid option --> error message on stderr
  $(basename $0) $GS_HOME/alt_bin/examples/hello.st -D -- -x  # run hello.st with an invalid option --> bring up topaz debugger

HELP
}

stashFile=`realpath $1`
scriptName="$(basename -- $1)"
shift
scriptArgs=""
launcherVmArgs=""

interpArgs="$*"

for argument in $@ ; do
	if [ "$argument" = "--" ] ; then
		launcherVmArgs=$scriptArgs
		args=($launcherVmArgs)
#		case ${args[0]} in
#			-*) # allow imageName to be optional first argument
#				;;
#			*) imageName=${args[0]} ;;
#		esac
		
		scriptArgs=""
	else
		scriptArgs+=" $argument"
	fi
done

debugCommandError="false"
for argument in $launcherVmArgs ; do
	case "$argument" in
		-D) debugCommandError="true" ;;
		-H) usage; exit 0 ;;
		-V) set -x ;;
		*);;
	esac
done

#
#	this generates the topaz code to execute the script in then gsdevkit_launcher solo extent
#
if [ "$debugCommandError" = "true" ] ; then
	ifErr1="iferr 1 stk"
	ifErr2="display oops"
	topazExit="EXITIFNOERROR"
else
	ifErr1="iferr 1 exit 1"
	ifErr2=""
	topazExit="EXIT"
fi
vmScriptFile=`mktemp -p /tmp tmp.XXXXXXXXXX.gsdevkit`
pwd=`pwd`
cat - > $vmScriptFile << EOF

$ifErr1
$ifErr2

set solologin on
login

status

run
	[
		AbstractGsDevKitProgram
			loadAndExecuteScriptClassFile: '$stashFile'
			args: '$scriptArgs'
			scriptName: '$scriptName'
			workingDir: '$pwd'.
		true	]
		on: StashCommandError, Error, Warning
		do: [:ex |
			(ex isKindOf: Warning)
				ifTrue: [
					$debugCommandError
						ifTrue: [ ex pass ]
						ifFalse: [ ex resume ] ].
			$debugCommandError
				ifTrue: [ ex pass ]
				ifFalse: [ 
					AbstractGsDevKitProgram
						ansiRedOn: AbstractGsDevKitProgram stderr 
						during: [ AbstractGsDevKitProgram stderr nextPutAll: ex description ].
					AbstractGsDevKitProgram stderr lf.
					false ] ].
%

$topazExit
EOF

export GEMSTONE="$GS_HOME/shared/gemstone/product"
$GEMSTONE/bin/topaz -lq \
										-I "$GS_HOME/shared/gemstone/.topazini" \
										-C "GEM_SOLO_EXTENT=$GS_HOME/shared/gemstone/snapshots/extent0.gsdevkit_launcher.dbf" \
										-S $vmScriptFile 

#################################################################################################
# https://github.com/mkropat/sh-realpath/blob/master/realpath.sh
#################################################################################################

realpath() {
    canonicalize_path "$(resolve_symlinks "$1")"
}

resolve_symlinks() {
    _resolve_symlinks "$1"
}

_resolve_symlinks() {
    _assert_no_path_cycles "$@" || return

    local dir_context path
    path=$(readlink -- "$1")
    if [ $? -eq 0 ]; then
        dir_context=$(dirname -- "$1")
        _resolve_symlinks "$(_prepend_dir_context_if_necessary "$dir_context" "$path")" "$@"
    else
        printf '%s\n' "$1"
    fi
}

_prepend_dir_context_if_necessary() {
    if [ "$1" = . ]; then
        printf '%s\n' "$2"
    else
        _prepend_path_if_relative "$1" "$2"
    fi
}

_prepend_path_if_relative() {
    case "$2" in
        /* ) printf '%s\n' "$2" ;;
         * ) printf '%s\n' "$1/$2" ;;
    esac
}

_assert_no_path_cycles() {
    local target path

    target=$1
    shift

    for path in "$@"; do
        if [ "$path" = "$target" ]; then
            return 1
        fi
    done
}

canonicalize_path() {
    if [ -d "$1" ]; then
        _canonicalize_dir_path "$1"
    else
        _canonicalize_file_path "$1"
    fi
}

_canonicalize_dir_path() {
    (cd "$1" 2>/dev/null && pwd -P)
}

_canonicalize_file_path() {
    local dir file
    dir=$(dirname -- "$1")
    file=$(basename -- "$1")
    (cd "$dir" 2>/dev/null && printf '%s/%s\n' "$(pwd -P)" "$file")
}

