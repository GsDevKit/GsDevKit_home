#!/usr/bin/env superdoit_solo
instvars
%
options
{
	SuperDoitOptionalOptionWithNoArg long: 'recovery' short: 'R'.
}
%
usage
-----
USAGE $basename [--help] [-R] stone-name [snapshot-file-path] [file-media-type]

DESCRIPTION
  Copy a fresh extent file to the given stone's extent directory.

OPTIONS
  -h, --help 		display usage message
  -R, --recovery	Copy a fresh extent file to the given stones extent directory, in preparation for a restore from backup.
   			Tranlog files are not removed, so that they can be used for recovery.
			See http://downloads.gemtalksystems.com/docs/GemStone64/3.2.x/GS64-SysAdmin-3.2/GS64-SysAdmin-3.2.htm for more info.

EXAMPLES
  $basename --help
  $basename myStone
  $basename myStone /opt/snapshots/mySnapshop.dbf
  $basename myStone /opt/snapshots/mySnapshot.dbf.gz x-gzip
  %basename -R myStone /opt/snapshots/mySnapshot.dbf
-----
%
projectshome
$GS_HOME/shared/gemstone/repos
%
specs
[
RwLoadSpecificationV2 {
	#specName : 'GsDevKit_SuperDoit',
	#projectName : 'GsDevKit_SuperDoit',
	#diskUrl : 'file:$GS_HOME/shared/gemstone/repos/GsDevKit_SuperDoit',
	#projectSpecFile : 'rowan/project.ston',
	#componentNames : [
		'GsDevKit'
	],
	#comment : 'loads GsDevKit support code in support of GsDevKit_home superDoit scripts'
}
]
%
method
newExtent
	| stoneDirectory extentFile tempenvvalue |
	(self positionalArgs size == 0 or:[ self recovery & (self positionalArgs size < 2) ]) ifTrue: [
		^ Error signal: 'Wrong number of arguments (' , self positionalArgs size printString , ')' ].
	tempenvvalue := System gemEnvironmentVariable: 'GEMSTONE'.
	System gemEnvironmentVariable: 'GEMSTONE' put: (System gemEnvironmentVariable: 'TARGET_GEMSTONE').
	stoneDirectory := self gs_stoneDirectory.
	self stderr 
		nextPutAll: 'New extent for ';
		nextPutAll: self stoneName;
		cr.
	extentFile := stoneDirectory / 'extents' / 'extent0.dbf'.
	extentFile exists
		ifTrue: [ extentFile delete ].
	self mediaType = 'x-gzip'
		ifTrue: [ self gunzipSnapshotExtent: stoneDirectory ]
		ifFalse: [ self copySnapshotExtent: stoneDirectory ].
	self stderr
		nextPutAll: 'Finished copying new extent for ';
		nextPutAll: self stoneName;
		cr.
	self recovery
		ifFalse:[ self removeTranlogs ].
	System gemEnvironmentVariable: 'GEMSTONE' put: tempenvvalue.
^ self noResult
%
method
snapshotFile
	self positionalArgs size < 2 ifTrue: [ ^ self gs_binDirectory / 'extent0.seaside.dbf' ].
	^ (self positionalArgs at: 2) asFileReference
%
method
mediaType
	self positionalArgs size < 3 ifTrue: [ ^ 'octet-stream' ].
	^ self positionalArgs at: 3
%
method
copySnapshotExtent: stoneDirectory
	"use copydbf, so that any corruption in the extent file can be found at the outset"

	self copySnapshotExtent: self snapshotFile to: stoneDirectory for: self stoneInfo gsVers
%
method
copySnapshotExtent: snapshotExtentFile to: stoneDirectory for: aGsVersionString
	"use copydbf, so that any corruption in the extent file can be found at the outset"

	| extentFile cmdPath |
	self stderr 
		nextPutAll: 'Copying extent file: ';
		nextPutAll: snapshotExtentFile pathString printString;
		cr.
	extentFile := stoneDirectory / 'extents' / 'extent0.dbf'.
	cmdPath := (aGsVersionString beginsWith: '2.4')
		ifTrue: [
			"cannot use copydbf to copy extent from product tree, so unconditionally use `cp`"
			'/bin/cp' ]
		ifFalse: [ (self gs_binDirectory / 'copydbf') pathString ].
	self stderr 
		nextPutAll: (GsHostProcess execute: cmdPath, ' "',(snapshotExtentFile pathString),'" "', (extentFile pathString), '"');
		cr.
	cmdPath := (GsHostProcess execute: '/usr/bin/which chmod') trimBoth.
	GsHostProcess execute: cmdPath, ' +w "' , extentFile pathString, '"'
%
method
gunzipSnapshotExtent: stoneDirectory
	| extentDir cmdPath |
	extentDir := stoneDirectory / 'extents'.
	self stderr 
		nextPutAll: 'Gunzipping extent file: ';
		nextPutAll: self snapshotFile pathString printString;
		nextPutAll: ' (copying to ';
		nextPutAll: extentDir pathString printString;
		nextPutAll: ' first)';
		cr.
	cmdPath := '/bin/cp'.
	self stderr 
		nextPutAll: (GsHostProcess execute: cmdPath,' "',(self snapshotFile pathString), '" "',((extentDir / 'extent0.dbf.gz') pathString), '"');
		cr.
	cmdPath := (GsHostProcess execute: '/usr/bin/which gunzip') trimBoth.
	self stderr 
		nextPutAll: (GsHostProcess execute: cmdPath,' "', ((extentDir / 'extent0.dbf.gz') pathString), '"');
		cr
%
method
removeTranlogs
	self stderr
		nextPutAll: 'Removing tranlogs for ';
		nextPutAll: self stoneName;
		cr.
	self removeTranlogs: self tranlogsHome.
	self stderr
		nextPutAll: 'Finished removing tranlogs for ';
		nextPutAll: self stoneName;
		cr.
%
method
removeTranlogs: tranlogDirectory
	tranlogDirectory deleteAllChildren
%
method
tranlogsHome
	^ self gs_stoneDirectory / 'tranlogs'
%
method
gs_stonesDirectory
	^  ((System gemEnvironmentVariable: 'GS_HOME'), '/server/stones') asFileReference
%
method
gs_stoneDirectory
	^  self gs_stonesDirectory / self stoneName
%
method
stoneName
	^ self positionalArgs at: 1
%
method
stoneInfoClass
	^ (self globalNamed: 'GsDevKitStoneInfo')
%
method
stoneInfoFilename
	^  'info.ston'
%
method
stoneInfo
	^ self stoneInfoClass importFrom: self gs_stoneDirectory / self stoneInfoFilename
%
method
gs_binDirectory
	^ (self gs_stoneDirectory / 'product' / 'bin') asFileReference
%
method
doit
	"override doit method, because ChildError does not exist in 3.6.0" 
	[ 
	self getAndVerifyOptions == self noResult
		ifTrue: [ ^ self noResult ].
	^ self theDoit
	]
		on: Error
		do: [ :ex | 
			((self respondsTo: #'debug') and: [ self debug ])
				ifTrue: [ ex pass ].
			self
				exit: ((ex respondsTo: #stderr)
					ifTrue: [ ex stderr asString trimBoth ]
					ifFalse: [ ex messageText ])
				withStatus: 1 "does not return" ].
%
doit
	self preDoitSpecLoad.	"load the GsDevKit_SuperDoit project from spec"
	self newExtent
%
